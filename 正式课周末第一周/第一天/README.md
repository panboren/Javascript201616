## 编写Mark需要做的准备
- 打开File-settings-plugin;
- 打开插件进行查找
![plugin](http://i1.piimg.com/4851/584f8eae8743f809.png)
- 重启webstrom(必须做的)
- 重启webstrom之后，会在Editor-fileType-markdown
![fileType](http://i1.piimg.com/4851/6681c00fb43a5cb7.jpg)
- 在新建的文件有两种操作：
    + 新建一个file文件，把文件名改为/.md$/的格式；（^开头，$结尾）
    + new->Edit File Templates,添加文件类型和后缀名，如下图
    ![fileType](http://p1.bqimg.com/4851/23046abea2428912.png)
## 常用命令
- 如何查看git安装成功  git --version
- 创建文件 touch index.html（注意：此时创建的html文件,一片空白 html:5+tab || !+tab）
- mkdir:创建文件夹  => rmdir:删除文件夹
- cd 文件夹的名称:进入文件夹
- touch xx.html 创建文件 =》删除文件： del xxx.html
mkdir 题  && cd 题 && touch 1.html
- 清屏：cls （Mac下：clear）
## 预解释
### 什么是预解释，为何学预解释
- 在当前作用域下，在JS代码执行之前，浏览器会对带var和带function的进行声明或定义
- 带var的，只声明不定义； 带function，声明+定义；
### 案例分析：
```
alert(n)
    n=15;
    function fn(){
        alert(n)
        n=34;
    }
    fn();
    alert(n);
```
- 作用域链概念：当函数被调用的时候，会形成一个私有作用域；在这个作用中查找是否有私有变量n
    + 如果有,当前作用域下的所有n，都是私有变量，跟外界没有任何关系；
    + 如果没有，去上级作用域进行查找，没有，继续往上找，一直找到window还没有的话，报错！
- 上级作用域：上级作用域跟函数在哪里调用无关，只跟函数对应的堆内存在哪里开辟有关；
- 带var 和 不带var的区别：
    + 带var的：1）会进行预解释 2）如果在全局下赋值的话，属于window的全局属性
    + 不带var的：1）不会进行预解释 2）赋值的时候，属于window的全局属性；
- 内存和内存释放：
    + 内存：栈内存和堆内存
        + 栈内存：提供了一个供JS代码执行的环境，包含：全局作用域和私有作用域
        + 堆内存：存放数据的；
            + 对象数据类型：以键值对的形式存储
            + 函数数据类型：代码字符串
    + 内存释放：
        + 栈内存释放：
            + 全局作用域的释放：因为全局作用域是在浏览器加载完页面的时候形成，所以，关系页面/关闭浏览器都可以释放
            + 私有作用域的释放：一般情况下，当函数执行完成的时候默认释放，有两种情况不释放：
                + 不释放：当函数执行完成的时候，函数体内有东西被外面的变量或者其他东西占用；
                + 不立即释放：当函数执行完成的时候，会返回一个还需要执行的函数，等所有函数都执行完成，就一起释放了；
                ```
                function fn(){
                    return 123
                }
                fn()();
                ```
        + 堆内存释放：var a=xxff00; 释放：a=null;
- 函数被调用的时候，有四步：
    1. 形成一个私有作用域
    2. 形参赋值
    3. 预解释
    4. 代码从上到下的执行；
- 预解释无节操：
    1. 只对等号左边带var,声明但不定义 var aa;
    2. 已经声明过的变量，不会进行重复声明
    3. 自执行函数不会进行预解释，只有执行到他的时候，声明+定义+调用，同步完成
    4. return后面的语句不会进行预解释，return下面的语句虽然不执行，但会进行预解释
    5. 条件判断语句中，无论条件是否成立，都会进行预解释（IE10及10以下）
- n++和++n的区别：
    + （++n）先++，再运算；
    + （n++）先运算，再++；
- 私有变量有两种：1）形参  2）函数中带var的；
- this总结：
    + 自执行函数中的this永远都是window
    + 当函数被调用的时候，点前面是谁，this就是谁？
    + 元素身上的事件被触发的时候，执行一个函数，函数中的this指向当前这个元素
    + 构造函数中的this都是实例；
